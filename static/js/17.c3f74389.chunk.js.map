{"version":3,"sources":["../node_modules/lodash/_Symbol.js","../node_modules/react-use/esm/useIsomorphicLayoutEffect.js","../node_modules/react-use/esm/useMeasure.js","../node_modules/lodash/clamp.js","../node_modules/lodash/_baseClamp.js","../node_modules/lodash/toNumber.js","../node_modules/lodash/isObject.js","../node_modules/lodash/isSymbol.js","../node_modules/lodash/_baseGetTag.js","../node_modules/lodash/_root.js","../node_modules/lodash/_freeGlobal.js","../node_modules/lodash/_getRawTag.js","../node_modules/lodash/_objectToString.js","../node_modules/lodash/isObjectLike.js","../../src/utils/math.ts","../../src/utils/rubberband.ts","../../src/utils/utils.ts","../../src/utils/resolveOptionsWith.ts","../../src/utils/event.ts","../../src/utils/config.ts","../../src/hooks/buildConfig.ts","../../src/utils/state.ts","../../src/recognizers/Recognizer.ts","../../src/Controller.ts","../../src/hooks/useRecognizers.ts","../../src/recognizers/CoordinatesRecognizer.ts","../../src/recognizers/DragRecognizer.ts","../../src/utils/memoize-one.ts","../../src/utils/react-fast-compare.ts","../../src/hooks/useDrag.ts","../node_modules/react-use/esm/useEvent.js","../node_modules/react-use/esm/useKey.js","../node_modules/react-use/esm/useKeyPress.js","../node_modules/react-use/esm/useKeyPressEvent.js"],"names":["Symbol","require","module","exports","useIsomorphicLayoutEffect","isBrowser","useLayoutEffect","useEffect","defaultState","x","y","width","height","top","left","bottom","right","window","ResizeObserver","_a","useState","element","ref","_b","rect","setRect","observer","useMemo","entries","contentRect","top_1","observe","disconnect","noop","baseClamp","toNumber","number","lower","upper","undefined","isObject","isSymbol","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","parseInt","value","other","valueOf","replace","isBinary","test","slice","type","baseGetTag","isObjectLike","getRawTag","objectToString","symToStringTag","toStringTag","Object","freeGlobal","freeSelf","self","root","Function","global","objectProto","prototype","hasOwnProperty","nativeObjectToString","toString","isOwn","call","tag","unmasked","e","result","addV","v1","v2","v","subV","calculateDistance","movement","Math","calculateAllKinematics","delta","dt","dl","alpha","beta","velocity","velocities","direction","distance","sign","Number","rubberband","dimension","constant","rubberband2","rubberbandIfOutOfBounds","position","min","max","minMax","chainFns","fns","fn","ensureVector","fallback","Error","Array","valueFn","args","resolveWith","config","resolvers","key","resolver","supportsTouchEvents","getEventTouches","event","getPointerIds","t","getGenericEventData","buttons","shiftKey","altKey","metaKey","ctrlKey","identity","xy","getPointerEventValues","transform","touchEvents","clientX","clientY","InternalGestureOptionsNormalizers","threshold","enabled","triggerAllEvents","initial","InternalCoordinatesOptionsNormalizers","axis","lockDirection","bounds","Infinity","InternalGenericOptionsNormalizers","domTarget","eventOptions","passive","capture","InternalDragOptionsNormalizers","useTouch","experimental_preventWindowScrollY","filterTaps","A","this","swipeVelocity","swipeDistance","swipeDuration","delay","getInternalGenericOptions","getInternalDragOptions","_buildDragConfig","rest","opts","getInitial","_active","_blocked","_intentional","_movement","_initial","_bounds","_lastEventType","_dragStarted","_dragPreventScroll","_dragIsTap","_dragDelayed","intentional","values","offset","lastOffset","previous","first","last","active","timeStamp","startTime","elapsedTime","cancel","canceled","memo","getInitialState","shared","hovering","scrolling","wheeling","dragging","moving","pinching","touches","down","locked","drag","_pointerId","vxvy","tap","swipe","pinch","_pointerIds","da","vdva","origin","turns","wheel","move","scroll","RecognizersMap","Recognizer","controller","debounced","setTimeout","ms","clearTimeout","fireGestureHandler","forceFlag","prev_active","next_active","state","document","newMemo","updateSharedState","updateGestureState","checkIntentionality","getMovement","T","wasIntentional","prevMovement","M","getInternalMovement","_T","map","i0","getIntentionalDisplacement","i1","intentionalityCheck","_rubberband","computeRubberband","clean","handlers","Vx","Vy","Rx","Ry","X1","X2","Y1","Y2","getGenericPayload","isStartEvent","getStartGestureState","stateKey","_state","partial","func","Controller","classes","pointerIds","touchIds","supportsGestureEvents","bind","bindings","RecognizerClass","handler","addBindings","updateDomListeners","getPropsListener","effect","getDomTargetFromConfig","removeListeners","takeAll","el","windowListeners","clearAllWindowListeners","addEventIds","idList","removeEventIds","clearWindowListeners","options","updateWindowListeners","listeners","addListeners","domListeners","name","props","captureString","fnsArray","array","eventName","eventHandler","useRecognizers","nativeHandlers","internalHandlers","resolveClasses","React","deprecationNoticeForDomTarget","process","CoordinatesRecognizer","absX","absY","getKinematics","mapStateValues","persistEvent","DragRecognizer","ingKey","setPointerCapture","target","pointerId","_dragTarget","_dragPointerId","releasePointerCapture","preventScroll","getEventId","isValidEvent","shouldPreventWindowScrollY","setUpWindowScrollDetection","setUpDelayedDragTrigger","setStartState","onDragStart","onDragChange","movementX","movementY","kinematics","genericEventData","genericPayload","realDistance","onDragEnd","vx","vy","mx","my","ix","iy","svx","svy","sx","sy","sd","endState","onCancel","onClick","startDrag","onDragIsStart","memoizeOne","resultFn","isEqual","lastArgs","calledOnce","newArgs","lastThis","lastResult","equal","a","b","length","i","Map","it","Set","keys","Element","error","console","useDrag","buildDragConfig","useRef","memoize","defaultTarget","isListenerType1","addEventListener","isListenerType2","on","useEvent","off","JSON","stringify","useKey","deps","useMemoHandler","keyFilter","predicate","handlerEvent","useKeyPress","set","useKeyPressEvent","keydown","keyup","useKeyPressDefault","pressed","useUpdateEffect"],"mappings":"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","file":"static/js/17.c3f74389.chunk.js","sourcesContent":["var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","import { useEffect, useLayoutEffect } from 'react';\nimport { isBrowser } from './misc/util';\nvar useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect;\nexport default useIsomorphicLayoutEffect;\n","import { useMemo, useState } from 'react';\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect';\nimport { isBrowser, noop } from './misc/util';\nvar defaultState = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0,\n};\nfunction useMeasure() {\n    var _a = useState(null), element = _a[0], ref = _a[1];\n    var _b = useState(defaultState), rect = _b[0], setRect = _b[1];\n    var observer = useMemo(function () {\n        return new window.ResizeObserver(function (entries) {\n            if (entries[0]) {\n                var _a = entries[0].contentRect, x = _a.x, y = _a.y, width = _a.width, height = _a.height, top_1 = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n                setRect({ x: x, y: y, width: width, height: height, top: top_1, left: left, bottom: bottom, right: right });\n            }\n        });\n    }, []);\n    useIsomorphicLayoutEffect(function () {\n        if (!element)\n            return;\n        observer.observe(element);\n        return function () {\n            observer.disconnect();\n        };\n    }, [element]);\n    return [ref, rect];\n}\nexport default isBrowser && typeof window.ResizeObserver !== 'undefined'\n    ? useMeasure\n    : function () { return [noop, defaultState]; };\n","var baseClamp = require('./_baseClamp'),\n    toNumber = require('./toNumber');\n\n/**\n * Clamps `number` within the inclusive `lower` and `upper` bounds.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Number\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n * @example\n *\n * _.clamp(-10, -5, 5);\n * // => -5\n *\n * _.clamp(10, -5, 5);\n * // => 5\n */\nfunction clamp(number, lower, upper) {\n  if (upper === undefined) {\n    upper = lower;\n    lower = undefined;\n  }\n  if (upper !== undefined) {\n    upper = toNumber(upper);\n    upper = upper === upper ? upper : 0;\n  }\n  if (lower !== undefined) {\n    lower = toNumber(lower);\n    lower = lower === lower ? lower : 0;\n  }\n  return baseClamp(toNumber(number), lower, upper);\n}\n\nmodule.exports = clamp;\n","/**\n * The base implementation of `_.clamp` which doesn't coerce arguments.\n *\n * @private\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n */\nfunction baseClamp(number, lower, upper) {\n  if (number === number) {\n    if (upper !== undefined) {\n      number = number <= upper ? number : upper;\n    }\n    if (lower !== undefined) {\n      number = number >= lower ? number : lower;\n    }\n  }\n  return number;\n}\n\nmodule.exports = baseClamp;\n","var isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","// vector add\nexport function addV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v + v2[i]) as T\n}\n\n// vector substract\nexport function subV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v - v2[i]) as T\n}\n\n/**\n * Calculates distance\n * @param movement the difference between current and initial vectors\n * @returns distance\n */\nexport function calculateDistance(movement: number[]): number {\n  return Math.hypot(...movement)\n}\n\ninterface Kinematics {\n  velocities: number[]\n  velocity: number\n  distance: number\n  direction: number[]\n}\n\nexport function calculateAllGeometry<T extends number[]>(movement: T, delta: T = movement) {\n  const dl = calculateDistance(delta)\n\n  const alpha = dl === 0 ? 0 : 1 / dl\n\n  const direction = delta.map(v => alpha * v) as T\n  const distance = calculateDistance(movement)\n\n  return { distance, direction }\n}\n\n/**\n * Calculates all kinematics\n * @template T the expected vector type\n * @param movement the difference between current and initial vectors\n * @param delta the difference between current and previous vectors\n * @param delta_t the time difference between current and previous timestamps\n * @returns all kinematics\n */\nexport function calculateAllKinematics<T extends number[]>(movement: T, delta: T, dt: number): Kinematics {\n  const dl = calculateDistance(delta)\n\n  const alpha = dl === 0 ? 0 : 1 / dl\n  const beta = dt === 0 ? 0 : 1 / dt\n\n  const velocity = beta * dl\n  const velocities = delta.map(v => beta * v)\n  const direction = delta.map(v => alpha * v)\n  const distance = calculateDistance(movement)\n\n  return { velocities, velocity, distance, direction }\n}\n\n/**\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\n * This polyfill function is suggested by Mozilla:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\n * @param x target number\n */\nexport function sign(x: number) {\n  if (Math.sign) return Math.sign(x)\n  return Number(x > 0) - Number(x < 0) || +x\n}\n","function minMax(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(value, max))\n}\n\n// Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\nfunction rubberband2(distance: number, constant: number) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5)\n}\n\nfunction rubberband(distance: number, dimension: number, constant: number) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant)\n  return (distance * dimension * constant) / (dimension + constant * distance)\n}\n\nexport function rubberbandIfOutOfBounds(position: number, min: number, max: number, constant = 0.15) {\n  if (constant === 0) return minMax(position, min, max)\n  if (position < min) return -rubberband(min - position, max - min, constant) + min\n  if (position > max) return +rubberband(position - max, max - min, constant) + max\n  return position\n}\n","export function noop() {}\n\n/**\n * TODO Beware that only optimized cases are covered in tests =)\n * TODO Need to cover general case as well\n *\n * @param fns\n */\nexport function chainFns(...fns: Function[]): Function {\n  if (fns.length === 0) return noop\n  if (fns.length === 1) return fns[0]\n\n  return function (this: any) {\n    var result\n    for (let fn of fns) {\n      result = fn.apply(this, arguments) || result\n    }\n    return result\n  }\n}\n\n/**\n * Expects a simple value or 2D vector (an array with 2 elements) and\n * always returns 2D vector. If simple value is passed, returns a\n * vector with this value as both coordinates.\n *\n * @param value\n */\nexport function ensureVector<T>(value: T | [T, T] | undefined, fallback?: T | [T, T]): [T, T] {\n  if (value === undefined) {\n    if (fallback === undefined) {\n      throw new Error('Must define fallback value if undefined is expected')\n    }\n    value = fallback\n  }\n\n  if (Array.isArray(value)) return value\n  return [value, value]\n}\n\n/**\n * Helper for defining a default value\n *\n * @param value\n * @param fallback\n */\nexport function assignDefault<T extends Object>(value: Partial<T> | undefined, fallback: T): T {\n  return Object.assign({}, fallback, value || {})\n}\n\n/**\n * Resolves getters (functions) by calling them\n * If simple value is given it just passes through\n *\n * @param v\n */\nexport function valueFn<T>(v: T | ((...args: any[]) => T), ...args: any[]): T {\n  if (typeof v === 'function') {\n    // @ts-ignore\n    return v(...args)\n  } else {\n    return v\n  }\n}\n","export type Resolver = (x: any, key: string, obj: object) => any\nexport type ResolverMap = { [k: string]: Resolver | ResolverMap | boolean }\n\nexport function resolveWith<T extends { [k: string]: any }, V extends { [k: string]: any }>(\n  config: Partial<T> = {},\n  resolvers: ResolverMap\n): V {\n  const result: any = {}\n\n  for (const [key, resolver] of Object.entries(resolvers))\n    switch (typeof resolver) {\n      case 'function':\n        result[key] = resolver.call(result, config[key], key, config)\n        break\n      case 'object':\n        result[key] = resolveWith(config[key], resolver)\n        break\n      case 'boolean':\n        if (resolver) result[key] = config[key]\n        break\n    }\n\n  return result\n}\n","import { Vector2, WebKitGestureEvent, DomEvents } from '../types'\n\nconst WEBKIT_DISTANCE_SCALE_FACTOR = 260\n\n/**\n * Whether the browser supports GestureEvent (ie Safari)\n * @returns true if the browser supports gesture event\n */\nexport function supportsGestureEvents(): boolean {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent\n  } catch (e) {\n    return false\n  }\n}\n\nexport function supportsTouchEvents(): boolean {\n  return typeof window !== 'undefined' && 'ontouchstart' in window\n}\n\nfunction getEventTouches(event: PointerEvent | React.PointerEvent | TouchEvent | React.TouchEvent) {\n  if ('pointerId' in event) return null\n  return event.type === 'touchend' ? event.changedTouches : event.targetTouches\n}\n\nexport function getPointerIds(event: PointerEvent | React.PointerEvent | TouchEvent | React.TouchEvent): number[] {\n  if ('pointerId' in event) return [event.pointerId]\n  return Array.from(getEventTouches(event)!).map(t => t.identifier)\n}\n\nexport function getGenericEventData(event: DomEvents) {\n  const buttons = 'buttons' in event ? event.buttons : 0\n  const { shiftKey, altKey, metaKey, ctrlKey } = event as any // TODO check if this might create some overrides?\n  return { buttons, shiftKey, altKey, metaKey, ctrlKey }\n}\n\nconst identity = (xy: Vector2) => xy\n\n/**\n * Gets pointer event values.\n * @param event\n * @returns pointer event values\n */\nexport function getPointerEventValues(\n  event: TouchEvent | React.TouchEvent | React.PointerEvent | PointerEvent,\n  transform = identity\n): Vector2 {\n  const touchEvents = getEventTouches(event)\n  const { clientX, clientY } = touchEvents ? touchEvents[0] : (event as React.PointerEvent)\n  return transform([clientX, clientY])\n}\n\n/**\n * Gets two touches event data\n * @param event\n * @returns two touches event data\n */\nexport function getTwoTouchesEventValues(\n  event: React.TouchEvent | TouchEvent,\n  pointerIds: [number, number],\n  transform = identity\n) {\n  const [A, B] = Array.from(event.touches).filter(t => pointerIds.includes(t.identifier))\n\n  const dx = B.clientX - A.clientX\n  const dy = B.clientY - A.clientY\n  const cx = (B.clientX + A.clientX) / 2\n  const cy = (B.clientY + A.clientY) / 2\n\n  // const e: any = 'nativeEvent' in event ? event.nativeEvent : event\n\n  const distance = Math.hypot(dx, dy)\n  // FIXME rotation has inconsistant values so we're not using it atm\n  // const angle = (e.rotation as number) ?? -(Math.atan2(dx, dy) * 180) / Math.PI\n  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI\n  const values: Vector2 = transform([distance, angle])\n  const origin: Vector2 = transform([cx, cy])\n\n  return { values, origin }\n}\n\n/**\n * Gets scroll event values\n * @param event\n * @returns scroll event values\n */\nexport function getScrollEventValues(event: React.UIEvent | UIEvent, transform = identity): Vector2 {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  const { scrollX, scrollY, scrollLeft, scrollTop } = event.currentTarget as Element & Window\n  return transform([scrollX || scrollLeft || 0, scrollY || scrollTop || 0])\n}\n\n// wheel delta defaults from https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js\nconst LINE_HEIGHT = 40\nconst PAGE_HEIGHT = 800\n\n/**\n * Gets wheel event values.\n * @param event\n * @returns wheel event values\n */\nexport function getWheelEventValues(event: React.WheelEvent | WheelEvent, transform = identity): Vector2 {\n  let { deltaX, deltaY, deltaMode } = event\n  // normalize wheel values, especially for Firefox\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT\n    deltaY *= LINE_HEIGHT\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT\n    deltaY *= PAGE_HEIGHT\n  }\n  return transform([deltaX, deltaY])\n}\n\n/**\n * Gets webkit gesture event values.\n * @param event\n * @returns webkit gesture event values\n */\nexport function getWebkitGestureEventValues(event: WebKitGestureEvent, transform = identity): Vector2 {\n  return transform([event.scale * WEBKIT_DISTANCE_SCALE_FACTOR, event.rotation])\n}\n","import { ensureVector, assignDefault, valueFn } from './utils'\nimport { resolveWith } from './resolveOptionsWith'\n\nimport {\n  GenericOptions,\n  InternalGenericOptions,\n  DragConfig,\n  GestureOptions,\n  InternalDragOptions,\n  InternalGestureOptions,\n  CoordinatesConfig,\n  InternalCoordinatesOptions,\n  DistanceAngleConfig,\n  InternalDistanceAngleOptions,\n  Vector2,\n  Bounds,\n  StateKey,\n  State,\n  CoordinatesKey,\n  DistanceAngleKey,\n} from '../types'\nimport { supportsTouchEvents } from './event'\n\nexport const DEFAULT_DRAG_DELAY = 180\nexport const DEFAULT_RUBBERBAND = 0.15\nexport const DEFAULT_SWIPE_VELOCITY = 0.5\nexport const DEFAULT_SWIPE_DISTANCE = 50\nexport const DEFAULT_SWIPE_DURATION = 250\n\nconst InternalGestureOptionsNormalizers = {\n  threshold(value: number | Vector2 = 0) {\n    return ensureVector(value)\n  },\n\n  rubberband(value: number | boolean | Vector2 = 0): Vector2 {\n    switch (value) {\n      case true:\n        return ensureVector(DEFAULT_RUBBERBAND)\n      case false:\n        return ensureVector(0)\n      default:\n        return ensureVector(value)\n    }\n  },\n\n  enabled(value = true) {\n    return value\n  },\n\n  triggerAllEvents(value = false) {\n    return value\n  },\n\n  initial(value = 0) {\n    if (typeof value === 'function') return value\n    return ensureVector(value)\n  },\n\n  transform: true,\n}\n\nconst InternalCoordinatesOptionsNormalizers = {\n  ...InternalGestureOptionsNormalizers,\n  axis: true,\n  lockDirection(value = false) {\n    return value\n  },\n  bounds(value: Bounds | ((state?: State) => Bounds) = {}) {\n    if (typeof value === 'function')\n      return (state?: State) => InternalCoordinatesOptionsNormalizers.bounds(value(state))\n\n    const { left = -Infinity, right = Infinity, top = -Infinity, bottom = Infinity } = value\n\n    return [\n      [left, right],\n      [top, bottom],\n    ]\n  },\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement\n\nconst InternalGenericOptionsNormalizers = {\n  enabled(value = true) {\n    return value\n  },\n  domTarget: true,\n  window(value = isBrowser ? window : undefined) {\n    return value\n  },\n  eventOptions({ passive = true, capture = false } = {}) {\n    return { passive, capture }\n  },\n  transform: true,\n}\n\nconst InternalDistanceAngleOptionsNormalizers = {\n  ...InternalGestureOptionsNormalizers,\n\n  bounds(_value: undefined, _key: string, { distanceBounds = {}, angleBounds = {} }) {\n    const _distanceBounds = (state?: State) => {\n      const D = assignDefault(valueFn(distanceBounds, state), { min: -Infinity, max: Infinity })\n      return [D.min, D.max]\n    }\n\n    const _angleBounds = (state?: State) => {\n      const A = assignDefault(valueFn(angleBounds, state), { min: -Infinity, max: Infinity })\n      return [A.min, A.max]\n    }\n\n    if (typeof distanceBounds !== 'function' && typeof angleBounds !== 'function')\n      return [_distanceBounds(), _angleBounds()]\n\n    return (state?: State) => [_distanceBounds(state), _angleBounds(state)]\n  },\n}\n\nconst InternalDragOptionsNormalizers = {\n  ...InternalCoordinatesOptionsNormalizers,\n\n  useTouch(value = false) {\n    return value && supportsTouchEvents()\n  },\n  experimental_preventWindowScrollY(value = false) {\n    return value\n  },\n  threshold(\n    this: InternalDragOptions,\n    v: number | Vector2 | undefined,\n    _k: string,\n    { filterTaps = false, lockDirection = false, axis = undefined }\n  ) {\n    const A = ensureVector(v, filterTaps ? 3 : lockDirection ? 1 : axis ? 1 : 0) as Vector2\n    this.filterTaps = filterTaps\n    return A\n  },\n\n  swipeVelocity(v: number | Vector2 = DEFAULT_SWIPE_VELOCITY) {\n    return ensureVector(v)\n  },\n  swipeDistance(v: number | Vector2 = DEFAULT_SWIPE_DISTANCE) {\n    return ensureVector(v)\n  },\n  swipeDuration(value = DEFAULT_SWIPE_DURATION) {\n    return value\n  },\n  delay(value: number | boolean = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY\n      case false:\n        return 0\n      default:\n        return value\n    }\n  },\n}\n\nexport function getInternalGenericOptions(config: GenericOptions = {}): InternalGenericOptions {\n  // TODO warn when passive is set to true and domTarget is undefined\n  return resolveWith<GenericOptions, InternalGenericOptions>(config, InternalGenericOptionsNormalizers)\n}\n\nexport function getInternalGestureOptions<T extends StateKey>(\n  config: GestureOptions<T> = {}\n): InternalGestureOptions<T> {\n  return resolveWith<GestureOptions<T>, InternalGestureOptions<T>>(config, InternalGestureOptionsNormalizers)\n}\n\nexport function getInternalCoordinatesOptions<T extends CoordinatesKey>(\n  config: CoordinatesConfig<T> = {}\n): InternalCoordinatesOptions<T> {\n  return resolveWith<CoordinatesConfig<T>, InternalCoordinatesOptions<T>>(config, InternalCoordinatesOptionsNormalizers)\n}\n\nexport function getInternalDistanceAngleOptions<T extends DistanceAngleKey>(\n  config: DistanceAngleConfig<T> = {}\n): InternalDistanceAngleOptions<T> {\n  return resolveWith<DistanceAngleConfig<T>, InternalDistanceAngleOptions<T>>(\n    config,\n    InternalDistanceAngleOptionsNormalizers\n  )\n}\n\nexport function getInternalDragOptions(config: DragConfig = {}): InternalDragOptions {\n  return resolveWith<DragConfig, InternalDragOptions>(config, InternalDragOptionsNormalizers)\n}\n","import {\n  InternalConfig,\n  UseMoveConfig,\n  UseHoverConfig,\n  UseDragConfig,\n  UsePinchConfig,\n  UseScrollConfig,\n  UseWheelConfig,\n} from '../types'\n\nimport {\n  getInternalGenericOptions,\n  getInternalCoordinatesOptions,\n  getInternalDragOptions,\n  getInternalDistanceAngleOptions,\n} from '../utils/config'\n\nimport { UseGestureConfig } from '../types'\n\nexport function _buildMoveConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseMoveConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.move = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function _buildHoverConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseHoverConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.hover = { enabled: true, ...rest }\n  return opts\n}\n\nexport function _buildDragConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseDragConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.drag = getInternalDragOptions(rest)\n  return opts\n}\n\nexport function _buildPinchConfig({ domTarget, eventOptions, window, enabled, ...rest }: UsePinchConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.pinch = getInternalDistanceAngleOptions(rest)\n  return opts\n}\n\nexport function _buildScrollConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseScrollConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.scroll = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function _buildWheelConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseWheelConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.wheel = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function buildComplexConfig(config: UseGestureConfig = {}, actions: Set<string> = new Set()) {\n  const { drag, wheel, move, scroll, pinch, hover, eventOptions, window, transform, domTarget, enabled } = config\n\n  const mergedConfig: InternalConfig = getInternalGenericOptions({\n    domTarget,\n    eventOptions,\n    transform,\n    window,\n    enabled,\n  })\n\n  if (actions.has('onDrag')) mergedConfig.drag = getInternalDragOptions(drag)\n  if (actions.has('onWheel')) mergedConfig.wheel = getInternalCoordinatesOptions(wheel)\n  if (actions.has('onScroll')) mergedConfig.scroll = getInternalCoordinatesOptions(scroll)\n  if (actions.has('onMove')) mergedConfig.move = getInternalCoordinatesOptions(move)\n  if (actions.has('onPinch')) mergedConfig.pinch = getInternalDistanceAngleOptions(pinch)\n  if (actions.has('onHover')) mergedConfig.hover = { enabled: true, ...hover }\n\n  return mergedConfig\n}\n","import { noop } from './utils'\nimport { CommonGestureState, Coordinates, State, DistanceAngle, Vector2, DragState, PinchState } from '../types'\n\nfunction getInitial<T>(mixed: T): T & CommonGestureState {\n  return {\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _bounds: [\n      [-Infinity, Infinity],\n      [-Infinity, Infinity],\n    ],\n    _lastEventType: undefined,\n    _dragStarted: false,\n    _dragPreventScroll: false,\n    _dragIsTap: true,\n    _dragDelayed: false,\n    event: undefined,\n    intentional: false,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined,\n    ...mixed,\n  }\n}\n\nexport function getInitialState(): State {\n  const shared = {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false,\n    locked: false,\n  }\n\n  const drag = getInitial<DragState & Coordinates>({\n    _pointerId: undefined,\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n    tap: false,\n    swipe: [0, 0],\n  })\n\n  const pinch = getInitial<DistanceAngle & PinchState>({\n    // @ts-expect-error when used _pointerIds we can assert its type will be [number, number]\n    _pointerIds: [],\n    da: [0, 0] as Vector2,\n    vdva: [0, 0] as Vector2,\n    // @ts-expect-error origin can never be passed as undefined in userland\n    origin: undefined,\n    turns: 0,\n  })\n\n  const wheel = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  const move = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  const scroll = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  return { shared, drag, pinch, wheel, move, scroll }\n}\n","import Controller from '../Controller'\nimport {\n  StateKey,\n  SharedGestureState,\n  IngKey,\n  InternalConfig,\n  GestureKey,\n  GestureState,\n  EventTypes,\n  PartialGestureState,\n  Vector2,\n  FullGestureState,\n  RecognizerClass,\n} from '../types'\nimport { getInitialState } from '../utils/state'\nimport { rubberbandIfOutOfBounds } from '../utils/rubberband'\nimport { subV, addV, sign } from '../utils/math'\nimport { valueFn } from '../utils/utils'\n\nexport const RecognizersMap = new Map<GestureKey, RecognizerClass>()\n\nconst identity = (xy: Vector2) => xy\n\n/**\n * @private\n * Recognizer abstract class.\n */\nexport default abstract class Recognizer<T extends StateKey = StateKey> {\n  abstract readonly ingKey: IngKey // dragging, scrolling, etc.\n  protected debounced: Boolean = true\n  abstract readonly stateKey: T\n\n  /**\n   * Creates an instance of a gesture recognizer.\n   * @param stateKey drag, move, pinch, etc.\n   * @param controller the controller attached to the gesture\n   * @param [args] the args that should be passed to the gesture handler\n   */\n  constructor(readonly controller: Controller, readonly args: any[] = []) {\n    this.controller = controller\n    this.args = args\n  }\n\n  // Returns the gesture config\n  get config(): NonNullable<InternalConfig[T]> {\n    return this.controller.config[this.stateKey]!\n  }\n\n  // Is the gesture enabled\n  get enabled(): boolean {\n    return this.controller.config.enabled && this.config.enabled\n  }\n\n  // Returns the controller state for a given gesture\n  get state(): GestureState<T> {\n    return this.controller.state[this.stateKey]\n  }\n\n  // Returns the gesture handler\n  get handler() {\n    return this.controller.handlers[this.stateKey]!\n  }\n\n  get transform() {\n    return this.config.transform || this.controller.config.transform || identity\n  }\n\n  // Convenience method to update the shared state\n  protected updateSharedState(sharedState: Partial<SharedGestureState> | null) {\n    Object.assign(this.controller.state.shared, sharedState)\n  }\n\n  // Convenience method to update the gesture state\n  protected updateGestureState(gestureState: PartialGestureState<T> | null) {\n    Object.assign(this.state, gestureState)\n  }\n\n  // Convenience method to set a timeout for a given gesture\n  protected setTimeout = (callback: (...args: any[]) => void, ms: number = 140, ...args: any[]): void => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n    this.controller.timeouts[this.stateKey] = window.setTimeout(callback, ms, ...args)\n  }\n\n  // Convenience method to clear a timeout for a given gesture\n  protected clearTimeout = () => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n  }\n\n  protected abstract getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T>\n\n  protected abstract getInternalMovement(values: Vector2, state: GestureState<T>): Vector2\n\n  protected abstract mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'>\n\n  public abstract addBindings(bindings: any): void\n\n  /**\n   * Returns state properties depending on the movement and state.\n   *\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\n   * below.\n   */\n  protected checkIntentionality(\n    _intentional: [false | number, false | number],\n    _movement: Vector2\n  ): PartialGestureState<T> {\n    return { _intentional, _blocked: false } as PartialGestureState<T>\n  }\n\n  /**\n   * Returns basic movement properties for the gesture based on the next values and current state.\n   */\n  protected getMovement(values: Vector2): PartialGestureState<T> {\n    const { rubberband, threshold: T } = this.config\n\n    const { _bounds, _initial, _active, _intentional: wasIntentional, lastOffset, movement: prevMovement } = this.state\n    const M = this.getInternalMovement(values, this.state)\n\n    const _T = this.transform(T).map(Math.abs)\n\n    const i0 = wasIntentional[0] === false ? getIntentionalDisplacement(M[0], _T[0]) : wasIntentional[0]\n    const i1 = wasIntentional[1] === false ? getIntentionalDisplacement(M[1], _T[1]) : wasIntentional[1]\n\n    // Get gesture specific state properties based on intentionality and movement.\n    const intentionalityCheck = this.checkIntentionality([i0, i1], M)\n    if (intentionalityCheck._blocked) {\n      return { ...intentionalityCheck, _movement: M, delta: [0, 0] }\n    }\n\n    const _intentional = intentionalityCheck._intentional!\n    const _movement = M\n\n    /**\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\n     * It is calculated from the actual movement minus the threshold.\n     */\n    let movement: Vector2 = [\n      _intentional[0] !== false ? M[0] - _intentional[0] : 0,\n      _intentional[1] !== false ? M[1] - _intentional[1] : 0,\n    ]\n\n    const offset = addV(movement, lastOffset)\n\n    /**\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\n     * and offset can return within their bounds.\n     */\n    const _rubberband: Vector2 = _active ? rubberband : [0, 0]\n    movement = computeRubberband(_bounds, addV(movement, _initial), _rubberband)\n\n    return {\n      ...intentionalityCheck,\n      intentional: _intentional[0] !== false || _intentional[1] !== false,\n      _initial,\n      _movement,\n      movement,\n      values,\n      offset: computeRubberband(_bounds, offset, _rubberband),\n      delta: subV(movement, prevMovement),\n    } as PartialGestureState<T>\n  }\n\n  // Cleans the gesture. Can be overriden by gestures.\n  protected clean() {\n    this.clearTimeout()\n  }\n\n  /**\n   * Fires the gesture handler\n   */\n  protected fireGestureHandler = (forceFlag: boolean = false): FullGestureState<T> | null => {\n    /**\n     * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\n     * clean everything and don't do anything.\n     */\n    if (this.state._blocked) {\n      // we need debounced gestures to end by themselves\n      if (!this.debounced) {\n        this.state._active = false\n        this.clean()\n      }\n      return null\n    }\n\n    // If the gesture has no intentional dimension, don't fire the handler.\n    if (!forceFlag && !this.state.intentional && !this.config.triggerAllEvents) return null\n\n    if (this.state.intentional) {\n      const prev_active = this.state.active\n      const next_active = this.state._active\n\n      this.state.active = next_active\n      this.state.first = next_active && !prev_active\n      this.state.last = prev_active && !next_active\n\n      this.controller.state.shared[this.ingKey] = next_active // Sets dragging, pinching, etc. to the gesture active state\n    }\n    const touches = this.controller.pointerIds.size || this.controller.touchIds.size\n    const down = this.controller.state.shared.buttons > 0 || touches > 0\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...this.mapStateValues(this.state), // Sets xy or da to the gesture state values\n      locked: !!document.pointerLockElement,\n      touches,\n      down,\n    } as FullGestureState<T>\n\n    // @ts-expect-error\n    const newMemo = this.handler(state)\n\n    // Sets memo to the returned value of the handler (unless it's not undefined)\n    this.state.memo = newMemo !== void 0 ? newMemo : this.state.memo\n\n    return state\n  }\n}\n\n//--------------------------------------------\n\nfunction getIntentionalDisplacement(movement: number, threshold: number): number | false {\n  if (Math.abs(movement) >= threshold) {\n    return sign(movement) * threshold\n  } else {\n    return false\n  }\n}\n\nfunction computeRubberband(bounds: [Vector2, Vector2], [Vx, Vy]: Vector2, [Rx, Ry]: Vector2): Vector2 {\n  const [[X1, X2], [Y1, Y2]] = bounds\n\n  return [rubberbandIfOutOfBounds(Vx, X1, X2, Rx), rubberbandIfOutOfBounds(Vy, Y1, Y2, Ry)]\n}\n\n/**\n * Returns a generic, common payload for all gestures from an event.\n */\nexport function getGenericPayload<T extends StateKey>(\n  { state }: Recognizer<T>,\n  event: EventTypes[T],\n  isStartEvent?: boolean\n) {\n  const { timeStamp, type: _lastEventType } = event\n  const previous = state.values\n  const elapsedTime = isStartEvent ? 0 : timeStamp - state.startTime!\n  return { _lastEventType, event, timeStamp, elapsedTime, previous }\n}\n\n/**\n * Returns the reinitialized start state for the gesture.\n * Should be common to all gestures.\n */\nexport function getStartGestureState<T extends StateKey>(\n  { state, config, stateKey, args }: Recognizer<T>,\n  values: Vector2,\n  event: EventTypes[T]\n) {\n  const offset = state.offset\n  const startTime = event.timeStamp\n\n  const { initial, bounds } = config\n\n  const _state = {\n    ...getInitialState()[stateKey],\n    _active: true,\n    args,\n    values,\n    initial: values,\n    offset,\n    lastOffset: offset,\n    startTime,\n  }\n\n  return { ..._state, _initial: valueFn(initial, _state), _bounds: valueFn(bounds, _state) }\n}\n","import {\n  StateKey,\n  State,\n  Fn,\n  ReactEventHandlerKey,\n  ReactEventHandlers,\n  InternalConfig,\n  InternalHandlers,\n  RecognizerClass,\n} from './types'\nimport { supportsTouchEvents, supportsGestureEvents, getPointerIds } from './utils/event'\nimport { getInitialState } from './utils/state'\nimport { chainFns } from './utils/utils'\n\nfunction partial(func: Fn, state: any) {\n  return function (event: any, ...args: any) {\n    // @ts-ignore\n    return func.call(this, { ...state, event }, ...args)\n  }\n}\n\n/**\n * The controller will keep track of the state for all gestures and also keep\n * track of timeouts, and window listeners.\n */\nexport default class Controller {\n  public nativeRefs!: any\n  public config!: InternalConfig\n  public handlers!: InternalHandlers\n  public state: State // state for all gestures\n  public timeouts: { [stateKey in StateKey]?: number } // tracks timeouts of debounced gestures\n  public domListeners: [string, Fn][] // when config.domTarget is set, we attach events directly to the dom\n  public windowListeners: { [stateKey in StateKey]?: [string, Function][] } // keeps track of window listeners added by gestures (drag only at the moment)\n\n  public pointerIds = new Set<number>() // register Pointer Events pointerIds\n  public touchIds = new Set<number>() // register Touch Events identifiers\n  public supportsTouchEvents = supportsTouchEvents()\n  public supportsGestureEvents = supportsGestureEvents()\n\n  constructor(private classes: Set<RecognizerClass>) {\n    this.classes = classes\n    this.state = getInitialState()\n    this.timeouts = {}\n    this.domListeners = []\n    this.windowListeners = {}\n  }\n\n  public bind = (...args: any[]) => {\n    const bindings: { [key: string]: Function[] } = {}\n\n    for (let RecognizerClass of this.classes) new RecognizerClass(this, args).addBindings(bindings)\n\n    // we also add event bindings for native handlers\n    for (let [event, handler] of Object.entries(this.nativeRefs))\n      addBindings(bindings, event, partial(handler, { ...this.state.shared, args }))\n\n    if (this.config.domTarget) {\n      // If config.domTarget is set we add event listeners to it and return the clean function.\n      return updateDomListeners(this, bindings)\n    } else {\n      // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n      return getPropsListener(this, bindings)\n    }\n  }\n\n  public effect = () => {\n    if (this.config.domTarget) this.bind()\n    return this.clean\n  }\n\n  /**\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\n   */\n  public clean = (): void => {\n    const domTarget = getDomTargetFromConfig(this.config)\n    const { eventOptions } = this.config\n    if (domTarget) removeListeners(domTarget, takeAll(this.domListeners), eventOptions)\n    Object.values(this.timeouts).forEach(clearTimeout)\n    clearAllWindowListeners(this)\n  }\n}\n\nexport function addEventIds(\n  controller: Controller,\n  event: React.TouchEvent | TouchEvent | React.PointerEvent | PointerEvent\n) {\n  const idList = 'pointerId' in event ? controller.pointerIds : controller.touchIds\n  getPointerIds(event).forEach(idList.add, idList)\n}\n\nexport function removeEventIds(\n  controller: Controller,\n  event: React.TouchEvent | TouchEvent | React.PointerEvent | PointerEvent\n) {\n  const idList = 'pointerId' in event ? controller.pointerIds : controller.touchIds\n  getPointerIds(event).forEach(idList.delete, idList)\n}\n\nexport function clearAllWindowListeners(controller: Controller) {\n  const {\n    config: { window: el, eventOptions },\n    windowListeners,\n  } = controller\n  if (!el) return\n\n  for (let stateKey in windowListeners) {\n    const handlers = windowListeners[stateKey as StateKey]\n    removeListeners(el, handlers, eventOptions)\n  }\n\n  controller.windowListeners = {}\n}\n\nexport function clearWindowListeners(\n  { config, windowListeners }: Controller,\n  stateKey: StateKey,\n  options = config.eventOptions\n) {\n  if (!config.window) return\n  removeListeners(config.window, windowListeners[stateKey], options)\n  delete windowListeners[stateKey]\n}\n\nexport function updateWindowListeners(\n  { config, windowListeners }: Controller,\n  stateKey: StateKey,\n  listeners: [string, Fn][] = [],\n  options = config.eventOptions\n) {\n  if (!config.window) return\n  removeListeners(config.window, windowListeners[stateKey], options)\n  addListeners(config.window, (windowListeners[stateKey] = listeners), options)\n}\n\nfunction updateDomListeners({ config, domListeners }: Controller, bindings: { [key: string]: Function[] }) {\n  const domTarget = getDomTargetFromConfig(config)\n  if (!domTarget) throw new Error('domTarget must be defined')\n  const { eventOptions } = config\n\n  removeListeners(domTarget, takeAll(domListeners), eventOptions)\n\n  for (let [key, fns] of Object.entries(bindings)) {\n    const name = key.slice(2).toLowerCase()\n    domListeners.push([name, chainFns(...fns)])\n  }\n\n  addListeners(domTarget, domListeners, eventOptions)\n}\n\nfunction getPropsListener({ config }: Controller, bindings: { [key: string]: Function[] }) {\n  const props: ReactEventHandlers = {}\n  const captureString = config.eventOptions.capture ? 'Capture' : ''\n  for (let [event, fns] of Object.entries(bindings)) {\n    const fnsArray = Array.isArray(fns) ? fns : [fns]\n    const key = (event + captureString) as ReactEventHandlerKey\n    props[key] = chainFns(...(fnsArray as Fn[]))\n  }\n  return props\n}\n\nfunction takeAll<T>(array: Array<T> = []) {\n  return array.splice(0, array.length)\n}\n\nfunction getDomTargetFromConfig({ domTarget }: InternalConfig) {\n  return domTarget && 'current' in domTarget ? domTarget.current : domTarget\n}\n\n/**\n * bindings is an object which keys match ReactEventHandlerKeys.\n * Since a recognizer might want to bind a handler function to an event key already used by a previously\n * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\n * that key.\n */\nexport function addBindings(bindings: any, name: string, fn: Fn): void {\n  if (!bindings[name]) bindings[name] = []\n  bindings[name]!.push(fn)\n}\n\nfunction addListeners(el: EventTarget, listeners: Array<[string, Fn]> = [], options = {}) {\n  for (let [eventName, eventHandler] of listeners) {\n    el.addEventListener(eventName, eventHandler, options)\n  }\n}\n\nfunction removeListeners(el: EventTarget, listeners: Array<[string, Fn]> = [], options = {}) {\n  for (let [eventName, eventHandler] of listeners) {\n    el.removeEventListener(eventName, eventHandler, options)\n  }\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport React from 'react'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport Controller from '../Controller'\nimport {\n  InternalConfig,\n  HookReturnType,\n  InternalHandlers,\n  GenericOptions,\n  RecognizerClass,\n  NativeHandlers,\n} from '../types'\n\n/**\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\n *\n * @param handlers\n * @param classes\n * @param config\n * @param nativeHandlers - native handlers such as onClick, onMouseDown, etc.\n */\nexport default function useRecognizers<Config extends Partial<GenericOptions>>(\n  handlers: Partial<InternalHandlers>,\n  config: InternalConfig,\n  nativeHandlers: Partial<NativeHandlers> = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const classes = resolveClasses(handlers)\n\n  const controller = React.useMemo(() => new Controller(classes), [])\n  controller!.config = config\n  controller!.handlers = handlers\n  controller!.nativeRefs = nativeHandlers\n\n  React.useEffect(controller.effect, [])\n\n  // @ts-ignore\n  if (controller.config.domTarget) return deprecationNoticeForDomTarget\n  // @ts-ignore\n  return controller.bind\n}\n\nfunction deprecationNoticeForDomTarget() {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(\n      `Deprecation notice: When the \\`domTarget\\` option is specified, you don't need to write \\`useEffect(bind, [bind])\\` anymore: event binding is now made handled internally to this lib.\\n\\nNext version won't return anything when \\`domTarget\\` is provided, therefore your code will break if you try to call \\`useEffect\\`.`\n    )\n  }\n}\n\nfunction resolveClasses(internalHandlers: Partial<InternalHandlers>) {\n  const classes = new Set<RecognizerClass>()\n\n  if (internalHandlers.drag) classes.add(RecognizersMap.get('drag')!)\n  if (internalHandlers.wheel) classes.add(RecognizersMap.get('wheel')!)\n  if (internalHandlers.scroll) classes.add(RecognizersMap.get('scroll')!)\n  if (internalHandlers.move) classes.add(RecognizersMap.get('move')!)\n  if (internalHandlers.pinch) classes.add(RecognizersMap.get('pinch')!)\n  if (internalHandlers.hover) classes.add(RecognizersMap.get('hover')!)\n\n  return classes\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, subV } from '../utils/math'\nimport { Vector2, PartialGestureState, GestureState, CoordinatesKey } from '../types'\n\n/**\n * @private\n * Abstract class for coordinates-based gesture recongizers\n */\nexport default abstract class CoordinatesRecognizer<T extends CoordinatesKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into account)\n   */\n  protected getInternalMovement(values: Vector2, state: GestureState<T>): Vector2 {\n    return subV(values, state.initial)\n  }\n\n  /**\n   * In coordinates-based gesture, this function will detect the first intentional axis,\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\n   * if the first intentional axis doesn't match the specified axis in config.\n   */\n  protected checkIntentionality(\n    _intentional: [false | number, false | number],\n    _movement: Vector2\n  ): PartialGestureState<T> {\n    if (_intentional[0] === false && _intentional[1] === false) {\n      return { _intentional, axis: this.state.axis } as PartialGestureState<T>\n    }\n    const [absX, absY] = _movement.map(Math.abs)\n    const axis = this.state.axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined)\n    if (!this.config.axis && !this.config.lockDirection) return { _intentional, _blocked: false, axis } as any\n    if (!axis) return { _intentional: [false, false], _blocked: false, axis } as any\n    if (!!this.config.axis && axis !== this.config.axis) return { _intentional, _blocked: true, axis } as any\n    _intentional![axis === 'x' ? 1 : 0] = false\n    return { _intentional, _blocked: false, axis } as any\n  }\n\n  getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T> {\n    const state = this.getMovement(values)\n    if (!state._blocked) {\n      const dt = event.timeStamp - this.state.timeStamp!\n      Object.assign(state, calculateAllKinematics(state.movement!, state.delta!, dt))\n    }\n    return state\n  }\n\n  protected mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'> {\n    return { xy: state.values, vxvy: state.velocities } as Omit<PartialGestureState<T>, 'event'>\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateDistance, sign } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings, updateWindowListeners, clearWindowListeners, addEventIds, removeEventIds } from '../Controller'\n\nexport const TAP_DISTANCE_THRESHOLD = 3\nexport const SWIPE_MAX_ELAPSED_TIME = 220\n\nfunction persistEvent(event: React.PointerEvent | PointerEvent) {\n  'persist' in event && typeof event.persist === 'function' && event.persist()\n}\n\nexport class DragRecognizer extends CoordinatesRecognizer<'drag'> {\n  readonly ingKey = 'dragging'\n  readonly stateKey = 'drag'\n\n  // TODO add back when setPointerCapture is widely wupported\n  // https://caniuse.com/#search=setPointerCapture\n  private setPointerCapture = (event: React.PointerEvent | PointerEvent) => {\n    // don't perform pointere capture when user wants to use touch events or\n    // when a pointerLockElement exists as this would throw an error\n    if (this.config.useTouch || document.pointerLockElement) return\n\n    const { target, pointerId } = event\n    if (target && 'setPointerCapture' in target) {\n      // this would work in the DOM but doesn't with react three fiber\n      // target.addEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n      // @ts-expect-error\n      target.setPointerCapture(pointerId)\n    }\n    this.updateGestureState({ _dragTarget: target, _dragPointerId: pointerId })\n  }\n\n  private releasePointerCapture = () => {\n    if (this.config.useTouch || document.pointerLockElement) return\n\n    const { _dragTarget, _dragPointerId } = this.state\n    if (_dragPointerId && _dragTarget && 'releasePointerCapture' in _dragTarget) {\n      // this would work in the DOM but doesn't with react three fiber\n      // target.removeEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n      if (!('hasPointerCapture' in _dragTarget) || _dragTarget.hasPointerCapture(_dragPointerId))\n        try {\n          _dragTarget.releasePointerCapture(_dragPointerId)\n        } catch (e) {}\n    }\n  }\n\n  private preventScroll = (event: TouchEvent) => {\n    if (this.state._dragPreventScroll && event.cancelable) {\n      event.preventDefault()\n    }\n  }\n\n  private getEventId = (event: any): number => {\n    if (this.config.useTouch) return event.changedTouches[0].identifier\n    return event.pointerId\n  }\n\n  private isValidEvent = (event: any) => {\n    // if we were using pointer events only event.isPrimary === 1 would suffice\n    return this.state._pointerId === this.getEventId(event)\n  }\n\n  private shouldPreventWindowScrollY =\n    this.config.experimental_preventWindowScrollY && this.controller.supportsTouchEvents\n\n  private setUpWindowScrollDetection = (event: React.PointerEvent | PointerEvent) => {\n    persistEvent(event)\n    // we add window listeners that will prevent the scroll when the user has started dragging\n    updateWindowListeners(\n      this.controller,\n      this.stateKey,\n      [\n        ['touchmove', this.preventScroll],\n        ['touchend', this.clean.bind(this)],\n        ['touchcancel', this.clean.bind(this)],\n      ],\n      { passive: false }\n    )\n    this.setTimeout(this.startDrag.bind(this), 250, event)\n  }\n\n  private setUpDelayedDragTrigger = (event: React.PointerEvent | PointerEvent) => {\n    this.state._dragDelayed = true\n    persistEvent(event)\n    this.setTimeout(this.startDrag.bind(this), this.config.delay, event)\n  }\n\n  private setStartState = (event: React.PointerEvent | PointerEvent) => {\n    const values = getPointerEventValues(event, this.transform)\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      _pointerId: this.getEventId(event), // setting pointerId locks the gesture to this specific event\n    })\n\n    this.updateGestureState(this.getMovement(values))\n  }\n\n  onDragStart = (event: React.PointerEvent | PointerEvent): void => {\n    addEventIds(this.controller, event)\n    if (!this.enabled || this.state._active) return\n\n    this.setStartState(event)\n    this.setPointerCapture(event as PointerEvent)\n\n    if (this.shouldPreventWindowScrollY) this.setUpWindowScrollDetection(event)\n    else if (this.config.delay > 0) this.setUpDelayedDragTrigger(event)\n    else this.startDrag(event, true) // we pass the values to the startDrag event\n  }\n\n  startDrag(event: React.PointerEvent | PointerEvent, onDragIsStart: boolean = false) {\n    // startDrag can happen after a timeout, so we need to check if the gesture is still active\n    // as the user might have lift up the pointer in between.\n\n    if (\n      // if the gesture isn't active (probably means)\n      !this.state._active ||\n      // if the drag has already started we should ignore subsequent attempts\n      this.state._dragStarted\n    )\n      return\n\n    if (!onDragIsStart) this.setStartState(event)\n    this.updateGestureState({ _dragStarted: true, _dragPreventScroll: true, cancel: this.onCancel })\n    this.clearTimeout()\n    this.fireGestureHandler()\n  }\n\n  onDragChange = (event: PointerEvent): void => {\n    if (\n      // if the gesture was canceled or\n      this.state.canceled ||\n      // if onDragStart wasn't fired or\n      !this.state._active ||\n      // if the event pointerId doesn't match the one that initiated the drag\n      !this.isValidEvent(event) ||\n      // if the event has the same timestamp as the previous event\n      // note that checking type equality is ONLY for tests ¯\\_(ツ)_/¯\n      (this.state._lastEventType === event.type && event.timeStamp === this.state.timeStamp)\n    )\n      return\n\n    let values\n\n    if (document.pointerLockElement) {\n      const { movementX, movementY } = event\n      values = addV(this.transform([movementX, movementY]), this.state.values)\n    } else values = getPointerEventValues(event, this.transform)\n\n    const kinematics = this.getKinematics(values, event)\n\n    // if startDrag hasn't fired\n    if (!this.state._dragStarted) {\n      // If the gesture isn't active then respond to the event only if\n      // it's been delayed via the `delay` option, in which case start\n      // the gesture immediately.\n      if (this.state._dragDelayed) {\n        this.startDrag(event)\n        return\n      }\n      // if the user wants to prevent vertical window scroll when user starts dragging\n      if (this.shouldPreventWindowScrollY) {\n        if (!this.state._dragPreventScroll && kinematics.axis) {\n          // if the user is dragging horizontally then we should allow the drag\n          if (kinematics.axis === 'x') {\n            this.startDrag(event)\n          } else {\n            this.state._active = false\n            return\n          }\n        } else return\n      } else return\n    }\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n    const genericPayload = getGenericPayload(this, event)\n\n    // This verifies if the drag can be assimilated to a tap by checking\n    // if the real distance of the drag (ie not accounting for the threshold) is\n    // greater than the TAP_DISTANCE_THRESHOLD.\n    const realDistance = calculateDistance(kinematics._movement!)\n    let { _dragIsTap } = this.state\n    if (_dragIsTap && realDistance >= TAP_DISTANCE_THRESHOLD) _dragIsTap = false\n\n    this.updateGestureState({ ...genericPayload, ...kinematics, _dragIsTap })\n\n    this.fireGestureHandler()\n  }\n\n  onDragEnd = (event: PointerEvent): void => {\n    removeEventIds(this.controller, event)\n\n    // if the event pointerId doesn't match the one that initiated the drag\n    // we don't want to end the drag\n    if (!this.isValidEvent(event)) return\n    this.clean()\n\n    // if the gesture is no longer active (ie canceled)\n    // don't do anything\n    if (!this.state._active) return\n    this.state._active = false\n\n    const tap = this.state._dragIsTap\n    const [vx, vy] = this.state.velocities\n    const [mx, my] = this.state.movement\n    const [ix, iy] = this.state._intentional\n    const [svx, svy] = this.config.swipeVelocity\n    const [sx, sy] = this.config.swipeDistance\n    const sd = this.config.swipeDuration\n\n    const endState = {\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n    }\n\n    const swipe: [number, number] = [0, 0]\n\n    if (endState.elapsedTime < sd) {\n      if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx)\n      if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy)\n    }\n\n    this.updateSharedState({ buttons: 0 })\n    this.updateGestureState({ ...endState, tap, swipe })\n    this.fireGestureHandler(this.config.filterTaps && tap === true)\n  }\n\n  clean = (): void => {\n    super.clean()\n    this.state._dragStarted = false\n    this.releasePointerCapture()\n    clearWindowListeners(this.controller, this.stateKey)\n  }\n\n  onCancel = (): void => {\n    if (this.state.canceled) return\n    this.updateGestureState({ canceled: true, _active: false })\n    this.updateSharedState({ buttons: 0 })\n    setTimeout(() => this.fireGestureHandler(), 0)\n  }\n\n  onClick = (event: React.UIEvent | UIEvent): void => {\n    if (!this.state._dragIsTap) event.stopPropagation()\n  }\n\n  addBindings(bindings: any): void {\n    if (this.config.useTouch) {\n      addBindings(bindings, 'onTouchStart', this.onDragStart)\n      addBindings(bindings, 'onTouchMove', this.onDragChange) // this is needed for react-three-fiber\n      addBindings(bindings, 'onTouchEnd', this.onDragEnd)\n      addBindings(bindings, 'onTouchCancel', this.onDragEnd)\n    } else {\n      addBindings(bindings, 'onPointerDown', this.onDragStart)\n      addBindings(bindings, 'onPointerMove', this.onDragChange) // this is needed for react-three-fiber\n      addBindings(bindings, 'onPointerUp', this.onDragEnd)\n      addBindings(bindings, 'onPointerCancel', this.onDragEnd)\n    }\n\n    if (this.config.filterTaps) {\n      const handler = this.controller.config.eventOptions.capture ? 'onClick' : 'onClickCapture'\n      addBindings(bindings, handler, this.onClick)\n    }\n  }\n}\n","/**\n * Inlined from https://github.com/alexreardon/memoize-one\n */\n\nexport type EqualityFn = (newArgs: any[], lastArgs: any[]) => boolean\n\nexport default function memoizeOne<ResultFn extends (this: any, ...newArgs: any[]) => ReturnType<ResultFn>>(\n  resultFn: ResultFn,\n  isEqual: EqualityFn\n): ResultFn {\n  let lastThis: unknown\n  let lastArgs: unknown[] = []\n  let lastResult: ReturnType<ResultFn>\n  let calledOnce: boolean = false\n\n  function memoized(this: unknown, ...newArgs: unknown[]): ReturnType<ResultFn> {\n    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n      return lastResult\n    }\n\n    lastResult = resultFn.apply(this, newArgs)\n    calledOnce = true\n    lastThis = this\n    lastArgs = newArgs\n    return lastResult\n  }\n\n  return memoized as ResultFn\n}\n","/**\n * Taken from https://github.com/FormidableLabs/react-fast-compare\n *\n * Dropped comments and ArrayBuffer handling\n */\n\nfunction equal(a: any, b: any): boolean {\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false\n\n    let length, i, keys\n    if (Array.isArray(a)) {\n      length = a.length\n      if (length !== b.length) return false\n      for (i = length; i-- !== 0; ) if (!equal(a[i], b[i])) return false\n      return true\n    }\n\n    let it\n    if (typeof Map === 'function' && a instanceof Map && b instanceof Map) {\n      if (a.size !== b.size) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!b.has(i.value[0])) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!equal(i.value[1], b.get(i.value[0]))) return false\n      return true\n    }\n\n    if (typeof Set === 'function' && a instanceof Set && b instanceof Set) {\n      if (a.size !== b.size) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!b.has(i.value[0])) return false\n      return true\n    }\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf()\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString()\n\n    keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    if (typeof Element !== 'undefined' && a instanceof Element) return false\n\n    for (i = length; i-- !== 0; ) {\n      if (keys[i] === '_owner' && a.$$typeof) continue\n      if (!equal(a[keys[i]], b[keys[i]])) return false\n    }\n    return true\n  }\n\n  // true if both NaN, false otherwise — NaN !== NaN → true\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n\nexport default function isEqual(a: any, b: any) {\n  try {\n    return equal(a, b)\n  } catch (error) {\n    if ((error.message || '').match(/stack|recursion/i)) {\n      console.warn('react-fast-compare cannot handle circular refs')\n      return false\n    }\n    throw error\n  }\n}\n","import { UseDragConfig, Handler, EventTypes } from '../types'\nimport { _buildDragConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { DragRecognizer } from '../recognizers/DragRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Drag hook.\n *\n * @param handler - the function fired every time the drag gesture updates\n * @param [config={}] - the config object including generic options and drag options\n */\nexport function useDrag<K = EventTypes['drag']>(handler: Handler<'drag', K>, config: UseDragConfig | {} = {}) {\n  RecognizersMap.set('drag', DragRecognizer)\n  const buildDragConfig = useRef<any>()\n  if (!buildDragConfig.current) {\n    buildDragConfig.current = memoize(_buildDragConfig, isEqual)\n  }\n  return useRecognizers<UseDragConfig>({ drag: handler }, buildDragConfig.current(config))\n}\n","import { useEffect } from 'react';\nimport { isBrowser, off, on } from './misc/util';\nvar defaultTarget = isBrowser ? window : null;\nvar isListenerType1 = function (target) {\n    return !!target.addEventListener;\n};\nvar isListenerType2 = function (target) {\n    return !!target.on;\n};\nvar useEvent = function (name, handler, target, options) {\n    if (target === void 0) { target = defaultTarget; }\n    useEffect(function () {\n        if (!handler) {\n            return;\n        }\n        if (!target) {\n            return;\n        }\n        if (isListenerType1(target)) {\n            on(target, name, handler, options);\n        }\n        else if (isListenerType2(target)) {\n            target.on(name, handler, options);\n        }\n        return function () {\n            if (isListenerType1(target)) {\n                off(target, name, handler, options);\n            }\n            else if (isListenerType2(target)) {\n                target.off(name, handler, options);\n            }\n        };\n    }, [name, handler, target, JSON.stringify(options)]);\n};\nexport default useEvent;\n","import { useMemo } from 'react';\nimport useEvent from './useEvent';\nimport { noop } from './misc/util';\nvar createKeyPredicate = function (keyFilter) {\n    return typeof keyFilter === 'function'\n        ? keyFilter\n        : typeof keyFilter === 'string'\n            ? function (event) { return event.key === keyFilter; }\n            : keyFilter\n                ? function () { return true; }\n                : function () { return false; };\n};\nvar useKey = function (key, fn, opts, deps) {\n    if (fn === void 0) { fn = noop; }\n    if (opts === void 0) { opts = {}; }\n    if (deps === void 0) { deps = [key]; }\n    var _a = opts.event, event = _a === void 0 ? 'keydown' : _a, target = opts.target, options = opts.options;\n    var useMemoHandler = useMemo(function () {\n        var predicate = createKeyPredicate(key);\n        var handler = function (handlerEvent) {\n            if (predicate(handlerEvent)) {\n                return fn(handlerEvent);\n            }\n        };\n        return handler;\n    }, deps);\n    useEvent(event, useMemoHandler, target, options);\n};\nexport default useKey;\n","import { useState } from 'react';\nimport useKey from './useKey';\nvar useKeyPress = function (keyFilter) {\n    var _a = useState([false, null]), state = _a[0], set = _a[1];\n    useKey(keyFilter, function (event) { return set([true, event]); }, { event: 'keydown' }, [state]);\n    useKey(keyFilter, function (event) { return set([false, event]); }, { event: 'keyup' }, [state]);\n    return state;\n};\nexport default useKeyPress;\n","import useKeyPressDefault from './useKeyPress';\nimport useUpdateEffect from './useUpdateEffect';\nvar useKeyPressEvent = function (key, keydown, keyup, useKeyPress) {\n    if (useKeyPress === void 0) { useKeyPress = useKeyPressDefault; }\n    var _a = useKeyPress(key), pressed = _a[0], event = _a[1];\n    useUpdateEffect(function () {\n        if (!pressed && keyup) {\n            keyup(event);\n        }\n        else if (pressed && keydown) {\n            keydown(event);\n        }\n    }, [pressed]);\n};\nexport default useKeyPressEvent;\n"],"sourceRoot":""}